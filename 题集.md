# SLLists, Nested Classes, Sentinel Nodes
> 值传递 (pass-by-value)
```java
public class Foo {  
    public int x, y;  
  
    public Foo(int x, int y) {  
        this.x = x;  
        this.y = y;  
    }  
  
    public static void switcheroo(Foo a, Foo b) {  
        Foo temp = a;  
        a = b;  
        b = temp;  
    }  
  
    public static void fliperoo(Foo a, Foo b) {  
        Foo temp = new Foo(a.x, a.y);  
        a.x = b.x;  
        a.y = b.y;  
        b.x = temp.x;  
        b.y = temp.y;  
    }

	public static void main(String[] args) {  
    Foo foobar = new Foo(10, 20);  
    Foo baz = new Foo(30, 40);  

    switcheroo(foobar, baz);  
    // question1:foobar.x?foobar.y?baz.x?baz.y?
    fliperoo(foobar, baz);  
    // question2:foobar.x?foobar.y?baz.x?baz.y?
	}
}
```
```python
def switcheroo(a, b):
    a, b = b, a

x = [10, 20]
y = [30, 40]
switcheroo(x, y)
print(x, y)  # question3: print结果？
```

> answer

Question 1 (After switcheroo):
foobar.x: 10
foobar.y: 20
baz.x: 30
baz.y: 40 (变量完全没变)
Question 2 (After fliperoo):
foobar.x: 30
foobar.y: 40
baz.x: 10
baz.y: 20 (对象内部的值互换了)
Question 3 (Python):
print 结果: \[10, 20\] \[30, 40\] (完全没变)
# DLLists,Arrays
## 1、DLList+尾节点
**（有关如何在已经基本构造好的DLList后面正确地加上一个尾节点，从而消除空指针异常）**
修改下面的代码，使 DMSList 的 max 方法能够正常工作。假设插入 DMSList 的所有数字都是正数，并且只通过 insertFront 方法插入。 你不能修改已有代码，只能填空。可能不需要填满所有空行。
```java
public class DMSList {
    private IntNode sentinel;
    public DMSList() {
        sentinel = new IntNode(-1000, ____________________);
    }
    public class IntNode {
        public int item;
        public IntNode next;
        public IntNode(int i, IntNode h) {
            item = i;
            next = h;
        }
        public int max() {
            // 递归调用 next.max()
            return Math.max(item, next.max());
        }
    }
    
    // 这里有一大段填空，需要定义一个新的结构
    public _________________________ {
    __________________________________________________
    __________________________________________________
    __________________________________________________
    __________________________________________________
    __________________________________________________
    __________________________________________________
    __________________________________________________
    }
    
    /* 如果链表为空返回 0。否则，返回最大元素。 */
    public int max() {
        return sentinel.next.max();
    }
    
    public void insertFront(int x) { sentinel.next = new IntNode(x, sentinel.next); }
}
```

> answer
```java
public class DMSList {
    private IntNode sentinel;
    
    public DMSList() {
        // 核心填空1：初始化时，sentinel 指向一个 LastIntNode
        // 这样链表永远以 LastIntNode 结尾，避免了 NullPointerException
        sentinel = new IntNode(-1000, new LastIntNode());
    }

    public class IntNode {
        public int item;
        public IntNode next;
        
        public IntNode(int i, IntNode h) {
            item = i;
            next = h;
        }
        
        public int max() {
            // 递归调用：当前值和下一个节点的 max 值比较
            // 如果 next 是 LastIntNode，就会调用下面重写的 max() 方法
            return Math.max(item, next.max());
        }
    }

    // 核心填空2：定义一个特殊的类来表示链表的末尾
    public class LastIntNode extends IntNode {
        public LastIntNode() {
            // 调用父类构造器，item 存 0（或者任何不影响 max 的小值），next 为 null
            super(0, null);
        }
        
        @Override
        public int max() {
            // Base Case：递归的终点
            // 返回 0，因为题目假设所有插入的数都是正数
            return 0;
        }
    }

    /* 如果链表为空返回 0。否则，返回最大元素。 */
    public int max() {
        return sentinel.next.max();
    }

    public void insertFront(int x) { 
        sentinel.next = new IntNode(x, sentinel.next); 
    }
}
```
## 2
```java
public class ArrayMystery {
    public static void main(String[] args) {
        int[] ls = new int[2];
        ls[0] = 100;
        int first = ls[0];
        
        ls[0] = 8;
        ls[1] = 9;
        
        System.out.println(first); 
        // Question 1

        int[][] triangle = new int[4][];
        triangle[0] = new int[]{1};
        
        int[] first1 = triangle[0];
        triangle[0] = new int[]{2};
        
        System.out.println(first1[0]); 
        // Question 2

        int[][] polygon = new int[4][];
        polygon[0] = new int[]{10};
        
        int[] first2 = polygon[0];
        polygon[0][0] = 20;
        
        System.out.println(first2[0]); 
        // Question 3
    }
}
```

> answer

Question 1: 100
Question 2: 1
Question 3: 20
# Inheritance, Implements
> 运行时多态
```java
interface Animal {
    default void sniff(Animal a) {
        System.out.println("sniff animal");
    }
    default void praise(Animal a) {
        System.out.println("u r cool animal");
    }
}

class Dog implements Animal {
    @Override
    public void sniff(Animal a) {
        System.out.println("dog sniff animal");
    }

    public void praise(Dog d) {
        System.out.println("u r cool dog");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a = new Dog();
        Dog d = new Dog();

        a.sniff(d);
        // Question 1: Output?

        d.praise(d);
        // Question 2: Output?

        a.praise(d);
        // Question 3: Output?
    }
}
```

> answer

**Question 1:** dog sniff animal 
**Question 2:** u r cool dog
**Question 3:** u r cool animal
> 编译器看到调用者 `a` 的**静态类型**是 `Animal`。
> 编译器检查 `Animal` 类型中所有名为 `praise` 的方法。**虽然没有`praise(Dog d)`，但找到了`praise(Animal a)`。**
> 由于传入的参数 `d`（类型为 `Dog`）可以向上转型为 `Animal`，所以这个调用是合法的。
> 因此，编译器在编译时就确定了要调用的方法**签名**是 `praise(Animal a)`
# Iterator
## 1、FilteredList
> 对于这种“跳跃式”“需要对节点进行判断来决定是否遍历”的，最好用hasNext来移动指针
> > **核心原则**：`curIndex` 永远指向**下一个即将被返回的合法元素**。如果已经没有合法元素了，它就指向列表末尾（或越界）
```java
public interface Predicate<T> {
    boolean test(T x);
}
```
```java
import java.util.*;
public class FilteredList<T> ________________ {
	// todo
	
    public FilteredList(List<T> L, Predicate<T> filter) {
		// todo
    }

    @Override
    public Iterator<T> iterator() {
		// todo
    }
		
	// todo 
}
```

> answer
```java
import java.util.*;

public interface Predicate<T> {
    boolean test(T x);
}

public class FilteredList<T> implements Iterable<T> {
    List<T> list;
    Predicate<T> pred;

    public FilteredList(List<T> L, Predicate<T> filter) {
        this.list = L;
        this.pred = filter;
    }

    @Override
    public Iterator<T> iterator() {
        return new FilteredListIterator();
    }

    private class FilteredListIterator implements Iterator<T> {
        int index;

        public FilteredListIterator() {
            index = 0;
        }

        @Override
        public boolean hasNext() {
            // 你的逻辑核心：只要没越界且当前元素不符合条件，就一直往后找
            while (index < list.size() && !pred.test(list.get(index))) {
                index += 1;
            }
            // 如果循环结束 index 还在范围内，说明找到了符合条件的元素
            return index < list.size();
        }

        @Override
        public T next() {
            // 先调用 hasNext 确保 index 移动到了下一个合法位置
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            
            T answer = list.get(index);
            
            // 关键点：取完值后，必须手动让 index 往前走一步
            // 否则下一次调用 hasNext 时，因为它会发现当前元素是合法的，就会死循环停在原地
            index += 1; 
            
            return answer;
        }
	}
}
```

## 2、轮询
> 实现一个 IteratorOfIterators，其参数是一个 List，其中每个元素都是 Iterator\<Integer\>。每次调用 next() 时，依次从列表中的迭代器取出元素：第一次从第一个迭代器取元素，第二次从第二个迭代器取元素……当某个迭代器为空时，应跳到下一个迭代器继续取值。所有迭代器都取完后，hasNext() 应返回 false。

```java
import java.util.*;

public class IteratorOfIterators implements Iterator<Integer> {
	// todo
	
    public IteratorOfIterators(List<Iterator<Integer>> a) {
        // todo
    }

    @Override
    public boolean hasNext() {
        // todo
    }

    @Override
    public Integer next() {
        // todo
    }
}
```

> answer

> 轮询优先考虑 LinkedList 或者 Deque（双端队列）
```java
import java.util.*;

public class IteratorOfIterators implements Iterator<Integer> {
    LinkedList<Iterator<Integer>> list;

    public IteratorOfIterators(List<Iterator<Integer>> a) {
        list = new LinkedList<>();        // 容易直接list = new LinkedList<>(a);而忽视对a中每个Iterator是否为空的检查
        for (Iterator<Integer> iter : a) {
            if (iter.hasNext()) {
                list.addLast(iter);
            }
        }
    }

    @Override
    public boolean hasNext() {
        return !list.isEmpty();
    }

    @Override
    public Integer next() {
        if (!hasNext()) {
            throw new NoSuchElementException();
        }
        Iterator<Integer> cur = list.removeFirst();     // LinkedList的removeFirst和addLast都是O(1)的操作
        Integer val = cur.next();
        if (cur.hasNext()) {
            list.addLast(cur);
        }
        return val;
    }
}
```
# Asymptotics
## 1
![[Pasted image 20251124163453.png|625]]
答案：

| 函数   | Best case        | Worst case    |
| ---- | ---------------- | ------------- |
| `g4` | $\Theta(N)$      | $\Theta(2^N)$ |
| `g5` | $\Theta(\log N)$ | $\Theta(N)$   |
## 2
![[Pasted image 20251124171154.png|625]]
答案：

| 函数   | 复杂度                |
| ---- | ------------------ |
| `f4` | $\Theta(N^2 logN)$ |
| `f5` | $O(N)$             |
## 3
> 假设我们在 WQU (Weighted Quick Union) 类中添加了一个名为 addToWQU 的方法。简单来说，该方法接受一个元素列表，并将它们随机连接在一起。假设在调用此方法之前，所有元素都是不连通的，并且 connect 方法的工作原理与课程中描述的一致。
```java
void addToWQU(int[] elements) {
    int[][] pairs = pairs(elements);
    pairs = shuffle(pairs);
    for (int[] pair : pairs) {
        connect(pair[0], pair[1]);
    }
}
```
> pairs 方法：接收一个数组，返回所有唯一的两两配对（unique pairs）。例如：输入 {1, 2, 3}，返回 {{1, 2}, {1, 3}, {2, 3}}。
> shuffle 方法：打乱这些配对的顺序。关键假设：为了简化问题，假设 pairs 和 shuffle 方法的运行时间是常数时间 $O(1)$（虽然实际中不可能，但这道题要求这样假设，意味着你不需要计算生成数组和打乱数组的时间开销，只需要关注循环部分）。
> 问题：请给出 addToWQU 的 大 $O$ (Big O) 运行时间________。
> 结果用 $N$ 表示，其中 $N$ 是 elements.length。


> answer

要考虑的关键：可不可以把最坏情况看做是“均摊”呢？

**试想一下这个过程：**
- **元素数量 ($N$)**：假设有 $1,000$ 个点。
- **循环次数 ($N^2$)**：我们要遍历约 $500,000$ 个配对（`pairs`）。
- **树的成型**：
    - 只要进行了 $N-1$ 次有效的连接（connect），这 1000 个点就有可能全部连通了，或者形成了很高的树。
    - 这意味着，在前 $1,000$ 次循环里，树可能就已经长到了最大深度 $\log N$。
虽然树在建立初期很矮，操作很快，但**循环并没有停下来**。
- **前 1,000 次操作**：可能确实很快，树慢慢长高。
- **剩下的 499,000 次操作**：
    - 这时候树已经长成了（假设最坏情况，深度接近 $\log N$）。
    - 虽然这两个点可能已经连通了，`connect` 不会做实质性的合并动作。
    - **但是！** 为了判断它们是否连通，程序必须调用 `find(p)` 和 `find(q)`
所以答案是$O(N^2 logN)$
## 4
> 最差的情况下时间复杂度是？（big O 表示法）
```java
void addToWQU(int[] elements) {
    int[][] pairs = pairs(elements);
    pairs = shuffle(pairs);
    for (int[] pair : pairs) {
        if (size() == elements.length) {
            return;
        }
        connect(pair[0], pair[1]);
    }
}
```

> answer

**最差的情况**
- 程序会遍历 `pairs` 数组中的前几千、几万张卡片。
- 虽然那 99 个点早就连好了，但因为第 100 个点还没连进来，`size()` 始终是 $N-1$（不等于 $N$）。
- **Result：** `if` 条件始终不满足，`return` 始终不触发。
- 程序被迫跑完几乎所有的配对。$O(N^2 logN)$
- 不是递归所以不能用主定理
## 5
我们定义 matching size connection (同尺寸连接) 为在 WQU (Weighted Quick Union) 中连接两个大小（size）相等的树（即连通分量）。 例如：假设有两棵树，一棵包含值 1 和 2，另一棵包含值 3 和 4。此时调用 connect(1, 4) 就是一次同尺寸连接，因为这两棵树的大小相同。
问题：在执行 addToWQU 之后，可能发生的同尺寸连接次数的 最小值 (minimum) 和 最大值 (maximum) 分别是多少？ 假设 N (即 elements.length) 是 2 的幂。请给出精确的答案。
minimum:？
maximum:?

> answer

1             N-1
## 6、双指针法
> 给定一个整数 x 和一个包含 $N$ 个不同整数的 有序 (sorted) 数组 A，请设计一个算法来判断是否存在索引 i 和 j，使得 A[i] + A[j] == x。
> 我们该如何改进下面这个解法？

```java
public static boolean findSum(int[] A, int x) {
    for (int i = 0; i < A.length; i++) {
        for (int j = 0; j < A.length; j++) {
            if (A[i] + A[j] == x) return true;
        }
    }
    return false;
}
```

> answer

```java
public static boolean findSum(int[] A, int x) {
	int left = 0;
	int right = A.length - 1;
	while (left <= right) {
		if (A[left] + A[right] == x) {
			return true;
		} else if (A[left] + A[right] < x) {
			left++;
		} else {
			right--;
		}
	}
	return false;
}
```
## 7、分治法
> 假设有一个如下定义的 `flip` 函数。假设 `unknown` 方法会在常数时间内返回一个 `1` 到 `N` 之间的随机整数（不包含 `N`）。
> 请针对下面定义的 `flop` 方法，写出 `flip` 函数在 Best Case（最好情况）和 Worst Case（最坏情况）下的时间复杂度，结果用 $\Theta(\cdot)$ 关于 `N` 的函数表示。
```java
public static void flip(int N) {
    if (N <= 100) {
        return;
    }
    int stop = unknown(N);
    for (int i = 1; i < N; i++) {
        if (i == stop) {
            flop(i, N);
            return;
        }
    }
}

public static void flop(int i, int N) {
      flip(N - i);
}

public static void flop(int i, int N) {
	int minimum = Math.min(i, N - i);
	flip(minimum);
	flip(minimum);
}

public static void flop(int i, int N) {
	flip(i);
	flip(N - i);
}
```
Best Case: Theta( ? )
Worst Case: Theta( ? )

> answer

$\Theta(N)$(❌)  $\Theta(N)$
$\Theta(1)$ $\Theta(N logN)$
$\Theta(N)$ $\Theta(N^2)$(❌)

> flip(N) 这个函数到底在做什么：随机切一刀：int stop = unknown(N) 选了一个数 $S$。处理切下来的一段：for 循环从 1 走到 stop。这里的花费是 $S$。递归处理剩下的部分：flop(i, N) 调用了 flip(N - i)，也就是 flip(N - S)。递推公式：$T(N) = S + T(N - S)$

> 题目问的是`runtime of flip`，那么flip就是程序的入口(Main)

> 为什么 $N \le 100$ 被忽略了？
> 当我们谈论 $\Theta(N)$ 或 $\Theta(1)$ 时，我们实际上是在问：“当 $N$ 趋向于无穷大（$N \to \infty$）时，运行时间的增长趋势是什么？”> 定义要求：渐进符号描述的是 $N$ 变得非常大时的行为。
> 常数截断：代码中的 if (N <= 100) 被称为“常数截断”（Constant Cutoff）。在数学上，无论这个阈值是 100、10,000 还是 10 亿，相对于“无穷大”，它都只是一个常数点。
## 8
> 确定 `prime_factors` 函数在最好和最坏情况下的运行时间，结果用 $\Theta(\cdot)$ 关于 `N` 的函数表示
```java
int prime_factors(int N) {
    int factor = 2;
    int count = 0;
    while (factor * factor <= N) {
        while (N % factor == 0) {
            System.out.println(factor);
            count += 1;
            N = N / factor;
        }
        factor += 1;
    }
    return count;
}
```
Best Case: Theta(    ), Worst Case: Theta(    )

> answer

$\Theta(logN)$   $\Theta(\sqrt{N})$
# ADT
> 在一堆元素中寻找出现次数`大于一次`（例如寻找选了不止一门课的学生）可以用两个Set的方法
> 遍历所有元素，如果该元素在Set1中不存在，说明是第一次出现，放进Set1，否则放进Set2,最后Set2就是答案

> 但如果是寻找具体多少次的，还是要用Map（Set只能用于`查重`)
# B-Tree
```java
/** 表示 2-4 树（又称 2-3-4 树）中的一个节点。
 * 这个基类本身只有一个实例，即 Node2_4.EMPTY，代表空树。 */
class Node2_4 {
    /** 唯一的空节点。 */
    final static Node2_4 EMPTY = new Node2_4();

    /** 返回我的第 K 个子节点（从 0 开始编号）。 */
    Node2_4 kid(int k) { /* 实现略 */ }

    /** 返回我的子节点数量（这比我的 Key 的数量多 1）。 */
    int arity() { /* 实现略 */ }

    /** 返回我的第 K 个 Key（从 0 开始编号）。 */
    String key(int k) { /* 实现略 */ }

    /** 当且仅当 Key 存在于以我为根的树中时，返回 true。 */
    boolean contains(String key) {
        return false;
    }
}

/** 表示非空节点。考试提示：Java 的条件判断具有短路特性，
    例如 'if (true || b)' 并不会去计算 b 的值。 */
class InnerNode2_4 extends Node2_4 {
    @Override
    boolean contains(String key) {
        for ( __________________________________________________ ) {
            if ( __________________________________________________ ) {
                return true;
            } else if ( __________________________________________________ ) {
                return kid(____________________).contains(key);
            }
        }
        return __________________________________________________
    }
}
```

> answer

for (...): int i = 0; i < arity() - 1; i++
if (...): key(i).equals(key)
else if (...): key.compareTo(key(i)) < 0
return kid(...): i
最后的 return: kid(arity() - 1).contains(key)
# Hashing
> 这样有什么问题？
```java
int hashCode = 0;
 for (int i = 0; i < x.length; i += 1) {
    hashCode *= R;
    hashCode += x.get(i).hashCode();
    hashCode = hashCode % M;
 }
 return hashCode;
```

> answer

```java
int hashCode = 0;
 for (int i = 0; i < x.length; i += 1) {
    hashCode *= R;
    hashCode += x.get(i).hashCode();
 }
 return hashCode % M;
```
原代码会导致哈希值只取决于字符串中所有字符的“总和”，而与顺序完全无关。