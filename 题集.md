# SLLists, Nested Classes, Sentinel Nodes
> 值传递 (pass-by-value)
```java
public class Foo {  
    public int x, y;  
  
    public Foo(int x, int y) {  
        this.x = x;  
        this.y = y;  
    }  
  
    public static void switcheroo(Foo a, Foo b) {  
        Foo temp = a;  
        a = b;  
        b = temp;  
    }  
  
    public static void fliperoo(Foo a, Foo b) {  
        Foo temp = new Foo(a.x, a.y);  
        a.x = b.x;  
        a.y = b.y;  
        b.x = temp.x;  
        b.y = temp.y;  
    }

	public static void main(String[] args) {  
    Foo foobar = new Foo(10, 20);  
    Foo baz = new Foo(30, 40);  

    switcheroo(foobar, baz);  
    // question1:foobar.x?foobar.y?baz.x?baz.y?
    fliperoo(foobar, baz);  
    // question2:foobar.x?foobar.y?baz.x?baz.y?
	}
}
```
```python
def switcheroo(a, b):
    a, b = b, a

x = [10, 20]
y = [30, 40]
switcheroo(x, y)
print(x, y)  # question3: print结果？
```

> answer

Question 1 (After switcheroo):
foobar.x: 10
foobar.y: 20
baz.x: 30
baz.y: 40 (变量完全没变)
Question 2 (After fliperoo):
foobar.x: 30
foobar.y: 40
baz.x: 10
baz.y: 20 (对象内部的值互换了)
Question 3 (Python):
print 结果: \[10, 20\] \[30, 40\] (完全没变)
# DLLists,Arrays
## 1、DLList+尾节点
**（有关如何在已经基本构造好的DLList后面正确地加上一个尾节点，从而消除空指针异常）**
修改下面的代码，使 DMSList 的 max 方法能够正常工作。假设插入 DMSList 的所有数字都是正数，并且只通过 insertFront 方法插入。 你不能修改已有代码，只能填空。可能不需要填满所有空行。
```java
public class DMSList {
    private IntNode sentinel;
    public DMSList() {
        sentinel = new IntNode(-1000, ____________________);
    }
    public class IntNode {
        public int item;
        public IntNode next;
        public IntNode(int i, IntNode h) {
            item = i;
            next = h;
        }
        public int max() {
            // 递归调用 next.max()
            return Math.max(item, next.max());
        }
    }
    
    // 这里有一大段填空，需要定义一个新的结构
    public _________________________ {
    __________________________________________________
    __________________________________________________
    __________________________________________________
    __________________________________________________
    __________________________________________________
    __________________________________________________
    __________________________________________________
    }
    
    /* 如果链表为空返回 0。否则，返回最大元素。 */
    public int max() {
        return sentinel.next.max();
    }
    
    public void insertFront(int x) { sentinel.next = new IntNode(x, sentinel.next); }
}
```

> answer
```java
public class DMSList {
    private IntNode sentinel;
    
    public DMSList() {
        // 核心填空1：初始化时，sentinel 指向一个 LastIntNode
        // 这样链表永远以 LastIntNode 结尾，避免了 NullPointerException
        sentinel = new IntNode(-1000, new LastIntNode());
    }

    public class IntNode {
        public int item;
        public IntNode next;
        
        public IntNode(int i, IntNode h) {
            item = i;
            next = h;
        }
        
        public int max() {
            // 递归调用：当前值和下一个节点的 max 值比较
            // 如果 next 是 LastIntNode，就会调用下面重写的 max() 方法
            return Math.max(item, next.max());
        }
    }

    // 核心填空2：定义一个特殊的类来表示链表的末尾
    public class LastIntNode extends IntNode {
        public LastIntNode() {
            // 调用父类构造器，item 存 0（或者任何不影响 max 的小值），next 为 null
            super(0, null);
        }
        
        @Override
        public int max() {
            // Base Case：递归的终点
            // 返回 0，因为题目假设所有插入的数都是正数
            return 0;
        }
    }

    /* 如果链表为空返回 0。否则，返回最大元素。 */
    public int max() {
        return sentinel.next.max();
    }

    public void insertFront(int x) { 
        sentinel.next = new IntNode(x, sentinel.next); 
    }
}
```
## 2
```java
public class ArrayMystery {
    public static void main(String[] args) {
        int[] ls = new int[2];
        ls[0] = 100;
        int first = ls[0];
        
        ls[0] = 8;
        ls[1] = 9;
        
        System.out.println(first); 
        // Question 1

        int[][] triangle = new int[4][];
        triangle[0] = new int[]{1};
        
        int[] first1 = triangle[0];
        triangle[0] = new int[]{2};
        
        System.out.println(first1[0]); 
        // Question 2

        int[][] polygon = new int[4][];
        polygon[0] = new int[]{10};
        
        int[] first2 = polygon[0];
        polygon[0][0] = 20;
        
        System.out.println(first2[0]); 
        // Question 3
    }
}
```

> answer

Question 1: 100
Question 2: 1
Question 3: 20
# Inheritance, Implements
> 运行时多态
```java
interface Animal {
    default void sniff(Animal a) {
        System.out.println("sniff animal");
    }
    default void praise(Animal a) {
        System.out.println("u r cool animal");
    }
}

class Dog implements Animal {
    @Override
    public void sniff(Animal a) {
        System.out.println("dog sniff animal");
    }

    public void praise(Dog d) {
        System.out.println("u r cool dog");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a = new Dog();
        Dog d = new Dog();

        a.sniff(d);
        // Question 1: Output?

        d.praise(d);
        // Question 2: Output?

        a.praise(d);
        // Question 3: Output?
    }
}
```

> answer

**Question 1:** dog sniff animal 
**Question 2:** u r cool dog
**Question 3:** u r cool animal
> 编译器看到调用者 `a` 的**静态类型**是 `Animal`。
> 编译器检查 `Animal` 类型中所有名为 `praise` 的方法。**虽然没有`praise(Dog d)`，但找到了`praise(Animal a)`。**
> 由于传入的参数 `d`（类型为 `Dog`）可以向上转型为 `Animal`，所以这个调用是合法的。
> 因此，编译器在编译时就确定了要调用的方法**签名**是 `praise(Animal a)`
# Iterator
## 1、FilteredList
> 对于这种“跳跃式”“需要对节点进行判断来决定是否遍历”的，最好用hasNext来移动指针
> > **核心原则**：`curIndex` 永远指向**下一个即将被返回的合法元素**。如果已经没有合法元素了，它就指向列表末尾（或越界）
```java
public interface Predicate<T> {
    boolean test(T x);
}
```
```java
import java.util.*;
public class FilteredList<T> ________________ {
	// todo
	
    public FilteredList(List<T> L, Predicate<T> filter) {
		// todo
    }

    @Override
    public Iterator<T> iterator() {
		// todo
    }
		
	// todo 
}
```

> answer
```java
import java.util.*;

public interface Predicate<T> {
    boolean test(T x);
}

public class FilteredList<T> implements Iterable<T> {
    List<T> list;
    Predicate<T> pred;

    public FilteredList(List<T> L, Predicate<T> filter) {
        this.list = L;
        this.pred = filter;
    }

    @Override
    public Iterator<T> iterator() {
        return new FilteredListIterator();
    }

    private class FilteredListIterator implements Iterator<T> {
        int index;

        public FilteredListIterator() {
            index = 0;
        }

        @Override
        public boolean hasNext() {
            // 你的逻辑核心：只要没越界且当前元素不符合条件，就一直往后找
            while (index < list.size() && !pred.test(list.get(index))) {
                index += 1;
            }
            // 如果循环结束 index 还在范围内，说明找到了符合条件的元素
            return index < list.size();
        }

        @Override
        public T next() {
            // 先调用 hasNext 确保 index 移动到了下一个合法位置
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            
            T answer = list.get(index);
            
            // 关键点：取完值后，必须手动让 index 往前走一步
            // 否则下一次调用 hasNext 时，因为它会发现当前元素是合法的，就会死循环停在原地
            index += 1; 
            
            return answer;
        }
	}
}
```

## 2、轮询
> 实现一个 IteratorOfIterators，其参数是一个 List，其中每个元素都是 Iterator\<Integer\>。每次调用 next() 时，依次从列表中的迭代器取出元素：第一次从第一个迭代器取元素，第二次从第二个迭代器取元素……当某个迭代器为空时，应跳到下一个迭代器继续取值。所有迭代器都取完后，hasNext() 应返回 false。

```java
import java.util.*;

public class IteratorOfIterators implements Iterator<Integer> {
	// todo
	
    public IteratorOfIterators(List<Iterator<Integer>> a) {
        // todo
    }

    @Override
    public boolean hasNext() {
        // todo
    }

    @Override
    public Integer next() {
        // todo
    }
}
```

> answer

> 轮询优先考虑 LinkedList 或者 Deque（双端队列）
```java
import java.util.*;

public class IteratorOfIterators implements Iterator<Integer> {
    LinkedList<Iterator<Integer>> list;

    public IteratorOfIterators(List<Iterator<Integer>> a) {
        list = new LinkedList<>();        // 容易直接list = new LinkedList<>(a);而忽视对a中每个Iterator是否为空的检查
        for (Iterator<Integer> iter : a) {
            if (iter.hasNext()) {
                list.addLast(iter);
            }
        }
    }

    @Override
    public boolean hasNext() {
        return !list.isEmpty();
    }

    @Override
    public Integer next() {
        if (!hasNext()) {
            throw new NoSuchElementException();
        }
        Iterator<Integer> cur = list.removeFirst();     // LinkedList的removeFirst和addLast都是O(1)的操作
        Integer val = cur.next();
        if (cur.hasNext()) {
            list.addLast(cur);
        }
        return val;
    }
}
```
# Asymptotics
## 1
![[Pasted image 20251124163453.png|625]]
答案：

| 函数   | Best case        | Worst case    |
| ---- | ---------------- | ------------- |
| `g4` | $\Theta(N)$      | $\Theta(2^N)$ |
| `g5` | $\Theta(\log N)$ | $\Theta(N)$   |
## 2
![[Pasted image 20251124171154.png|625]]
答案：

| 函数   | 复杂度                |
| ---- | ------------------ |
| `f4` | $\Theta(N^2 logN)$ |
| `f5` | $O(N)$             |
## 3
> 假设我们在 WQU (Weighted Quick Union) 类中添加了一个名为 addToWQU 的方法。简单来说，该方法接受一个元素列表，并将它们随机连接在一起。假设在调用此方法之前，所有元素都是不连通的，并且 connect 方法的工作原理与课程中描述的一致。
```java
void addToWQU(int[] elements) {
    int[][] pairs = pairs(elements);
    pairs = shuffle(pairs);
    for (int[] pair : pairs) {
        connect(pair[0], pair[1]);
    }
}
```
> pairs 方法：接收一个数组，返回所有唯一的两两配对（unique pairs）。例如：输入 {1, 2, 3}，返回 {{1, 2}, {1, 3}, {2, 3}}。
> shuffle 方法：打乱这些配对的顺序。关键假设：为了简化问题，假设 pairs 和 shuffle 方法的运行时间是常数时间 $O(1)$（虽然实际中不可能，但这道题要求这样假设，意味着你不需要计算生成数组和打乱数组的时间开销，只需要关注循环部分）。
> 问题：请给出 addToWQU 的 大 $O$ (Big O) 运行时间________。
> 结果用 $N$ 表示，其中 $N$ 是 elements.length。


> answer

要考虑的关键：可不可以把最坏情况看做是“均摊”呢？

**试想一下这个过程：**
- **元素数量 ($N$)**：假设有 $1,000$ 个点。
- **循环次数 ($N^2$)**：我们要遍历约 $500,000$ 个配对（`pairs`）。
- **树的成型**：
    - 只要进行了 $N-1$ 次有效的连接（connect），这 1000 个点就有可能全部连通了，或者形成了很高的树。
    - 这意味着，在前 $1,000$ 次循环里，树可能就已经长到了最大深度 $\log N$。
虽然树在建立初期很矮，操作很快，但**循环并没有停下来**。
- **前 1,000 次操作**：可能确实很快，树慢慢长高。
- **剩下的 499,000 次操作**：
    - 这时候树已经长成了（假设最坏情况，深度接近 $\log N$）。
    - 虽然这两个点可能已经连通了，`connect` 不会做实质性的合并动作。
    - **但是！** 为了判断它们是否连通，程序必须调用 `find(p)` 和 `find(q)`
所以答案是$O(N^2 logN)$
# B-Tree
```java
/** 表示 2-4 树（又称 2-3-4 树）中的一个节点。
 * 这个基类本身只有一个实例，即 Node2_4.EMPTY，代表空树。 */
class Node2_4 {
    /** 唯一的空节点。 */
    final static Node2_4 EMPTY = new Node2_4();

    /** 返回我的第 K 个子节点（从 0 开始编号）。 */
    Node2_4 kid(int k) { /* 实现略 */ }

    /** 返回我的子节点数量（这比我的 Key 的数量多 1）。 */
    int arity() { /* 实现略 */ }

    /** 返回我的第 K 个 Key（从 0 开始编号）。 */
    String key(int k) { /* 实现略 */ }

    /** 当且仅当 Key 存在于以我为根的树中时，返回 true。 */
    boolean contains(String key) {
        return false;
    }
}

/** 表示非空节点。考试提示：Java 的条件判断具有短路特性，
    例如 'if (true || b)' 并不会去计算 b 的值。 */
class InnerNode2_4 extends Node2_4 {
    @Override
    boolean contains(String key) {
        for ( __________________________________________________ ) {
            if ( __________________________________________________ ) {
                return true;
            } else if ( __________________________________________________ ) {
                return kid(____________________).contains(key);
            }
        }
        return __________________________________________________
    }
}
```

> answer

for (...): int i = 0; i < arity() - 1; i++
if (...): key(i).equals(key)
else if (...): key.compareTo(key(i)) < 0
return kid(...): i
最后的 return: kid(arity() - 1).contains(key)
# Hashing
> 这样有什么问题？
```java
int hashCode = 0;
 for (int i = 0; i < x.length; i += 1) {
    hashCode *= R;
    hashCode += x.get(i).hashCode();
    hashCode = hashCode % M;
 }
 return hashCode;
```

> answer

```java
int hashCode = 0;
 for (int i = 0; i < x.length; i += 1) {
    hashCode *= R;
    hashCode += x.get(i).hashCode();
 }
 return hashCode % M;
```
原代码会导致哈希值只取决于字符串中所有字符的“总和”，而与顺序完全无关。